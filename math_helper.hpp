#pragma once

#include <bit>
#include <cstdint>

#include "./fixed.hpp"
#include "./const.hpp"

namespace fxd::impl {

// Uses the first 7 fraction bits to lookup an initial estimate.
// All lookup tables are in unsigned Q1.31 format.

constexpr inline u32 rsqrt_lut[128] = {
    2147483648, 2139143874, 2130900514, 2122751725, 2114695712, 2106730728, 2098855072, 2091067086, 
    2083365155, 2075747706, 2068213207, 2060760162, 2053387115, 2046092644, 2038875363, 2031733921, 
    2024666999, 2017673310, 2010751597, 2003900635, 1997119226, 1990406201, 1983760419, 1977180764, 
    1970666148, 1964215505, 1957827795, 1951502002, 1945237132, 1939032213, 1932886295, 1926798449, 
    1920767766, 1914793358, 1908874353, 1903009902, 1897199171, 1891441346, 1885735627, 1880081235, 
    1874477403, 1868923384, 1863418443, 1857961862, 1852552937, 1847190978, 1841875309, 1836605269, 
    1831380208, 1826199490, 1821062491, 1815968600, 1810917217, 1805907755, 1800939636, 1796012295, 
    1791125178, 1786277739, 1781469446, 1776699774, 1771968208, 1767274244, 1762617387, 1757997150, 
    1753413056, 1748864635, 1744351429, 1739872984, 1735428857, 1731018611, 1726641819, 1722298059, 
    1717986918, 1713707990, 1709460876, 1705245183, 1701060526, 1696906525, 1692782810, 1688689012, 
    1684624773, 1680589738, 1676583558, 1672605893, 1668656405, 1664734763, 1660840641, 1656973719, 
    1653133683, 1649320220, 1645533028, 1641771804, 1638036255, 1634326089, 1630641020, 1626980766, 
    1623345050, 1619733599, 1616146145, 1612582423, 1609042172, 1605525135, 1602031061, 1598559701, 
    1595110808, 1591684143, 1588279467, 1584896547, 1581535150, 1578195051, 1574876026, 1571577852, 
    1568300314, 1565043197, 1561806289, 1558589383, 1555392273, 1552214757, 1549056637, 1545917714, 
    1542797796, 1539696692, 1536614213, 1533550174, 1530504391, 1527476684, 1524466875, 1521474788
};

constexpr inline u32 rcp_lut[128] = {
    2147483648, 2130836487, 2114445438, 2098304633, 2082408385, 2066751180, 2051327663, 2036132644,
    2021161080, 2006408079, 1991868890, 1977538898, 1963413621, 1949488701, 1935759908, 1922223125,
    1908874353, 1895709703, 1882725390, 1869917734, 1857283155, 1844818167, 1832519379, 1820383489,
    1808407282, 1796587627, 1784921473, 1773405851, 1762037865, 1750814693, 1739733588, 1728791867,
    1717986918, 1707316192, 1696777203, 1686367527, 1676084798, 1665926708, 1655891005, 1645975490,
    1636178017, 1626496490, 1616928864, 1607473140, 1598127365, 1588889635, 1579758085, 1570730896,
    1561806289, 1552982525, 1544257904, 1535630765, 1527099483, 1518662469, 1510318170, 1502065065,
    1493901668, 1485826524, 1477838209, 1469935331, 1462116526, 1454380460, 1446725826, 1439151345,
    1431655765, 1424237859, 1416896427, 1409630292, 1402438300, 1395319324, 1388272257, 1381296014,
    1374389534, 1367551775, 1360781717, 1354078359, 1347440720, 1340867838, 1334358771, 1327912593,
    1321528398, 1315205296, 1308942414, 1302738895, 1296593900, 1290506605, 1284476200, 1278501892,
    1272582902, 1266718465, 1260907830, 1255150260, 1249445031, 1243791434, 1238188770, 1232636354,
    1227133513, 1221679586, 1216273924, 1210915889, 1205604855, 1200340204, 1195121334, 1189947649,
    1184818564, 1179733506, 1174691910, 1169693221, 1164736893, 1159822392, 1154949188, 1150116765,
    1145324612, 1140572227, 1135859119, 1131184802, 1126548798, 1121950640, 1117389865, 1112866020,
    1108378657, 1103927337, 1099511627, 1095131103, 1090785345, 1086473940, 1082196484, 1077952576
};

template<std::integral T>
constexpr int ilog2(T value) {
    using ut = std::make_unsigned_t<T>;
    const ut bits = static_cast<ut>(value);
    return static_cast<int>(sizeof(T) * CHAR_BIT) - 
            std::countl_zero(bits) -
            std::is_signed_v<T>;
}

constexpr trig_t p1 = 0.7853981633974483096;
constexpr trig_t p3 = 2.3561944901923449288;
constexpr trig_t p5 = 3.9269908169872415481;
constexpr trig_t p7 = 5.4977871437821381673;
constexpr trig_t pstep = 0.63661977236758134308;

// ? Factorize these?

// Approximates cos(x) for x: [-pi/4, pi/4]
constexpr trig_t get_cos(trig_t x) {
    constexpr trig_t c1 = 0.04166666666666666667;
    constexpr trig_t c2 = 0.00138888888888888888;
    constexpr trig_t c3 = 0.00002480158730158730;
    const trig_t x2 = x * x;
    const trig_t x4 = x2 * x2;
    const trig_t x6 = x4 * x2;
    return 1 - (x2 >> 1) + (x4 * c1) - (x6 * c2) + (x6 * x2 * c3);
};

// Approximates sin(x) for x: [-pi/4, pi/4]
constexpr trig_t get_sin(trig_t x) {
    constexpr trig_t c1 = 0.16666666666666666667;
    constexpr trig_t c2 = 0.00833333333333333333;
    constexpr trig_t c3 = 0.00019841269841269841;
    const trig_t x2 = x * x;
    const trig_t x3 = x2 * x;
    const trig_t x5 = x3 * x2;
    return x - (x3 * c1) + (x5 * c2) - (x5 * x2 * c3);
};

// On some formats, the integer cannot store the number of fraction bits.
// So, as an emergancy, just set it to the minimum value.
// Please leave at least 5 integer bits on your formats for stability!

template<std::integral base, int fp>
consteval fixed<base, fp> get_min_exp2_input() {
    using fixed_t = fixed<base, fp>;

    if (fixed_t::is_signed) {
        if (fixed_t::frac_bits <= fixed_t::max_int)
            return -fixed_t::frac_bits;
        else
            return fixed_t::min();
    }
    else {
        return 0;
    }
}

// Functions specialized for certain algorithms.

constexpr trig_t asin_sqrt(trig_t s) {
    const int log2 = trig_t::frac_bits - impl::ilog2(s.raw());
    const trig_t x = s << (log2 - 1);
    const int idx = (x & (0xfe << 18)).raw() >> 19;

    trig_t y = trig_t::from_raw(impl::rsqrt_lut[idx] >> 4);
    y *= 1.5 - (x * y * y);
    y *= 1.5 - (x * y * y);

    y *= (x << 1);

    if (log2 & 1)
        y *= rsqrt_2<trig_t>;

    return y >> (log2 >> 1);
};

using log_t = fixed<int, 27>;

constexpr log_t log2_sqrt(log_t x) {
    const log_t s = x >> 1;
    const int idx = (s & (0xfe << 18)).raw() >> 19;
    log_t y = log_t::from_raw(impl::rsqrt_lut[idx] >> 4);
    y *= 1.5 - (s * y * y);
    y *= 1.5 - (s * y * y);
    y *= x;
    return y;
};

}